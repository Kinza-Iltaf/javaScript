<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM summary</title>
</head>
<body style="background-color: #212121; color : #fff;">

    <!-- DOM Learning summary
DOM => way to interact with webpage and manipulate it dynamically
Structures tree node => easily access elements and attributes 
document => object provide access to webpage DOM

target any element => getElementById (method)(id:name).anyfunction like
 id (will return id) 
className(will return class name of that specific element)
 getAttribute(pass key, return value (id:return idName))
setAttribute(its override (class,name))
 style.backgroundColor = colorName 

innerText => show all the display text

textContent => show all the content whether its hide by the styling or display

innerHTML => give all the html tag content means we have p tag and we used span tag inside it so it will show whole p element with span as well

querySelector(element name(h2)) => will return first selected element of the page but with HTML tags

querySelectorAll => will return all the element that are selected from the page

querrySelectorAll => we need to define index for any specific functionality

node list and html collection are not completely Array so it is not offering complete array functionalities like forEach, map etc so we need to convert it into array for which => Array.from(collectionName)

selecting parent element => querySelector => (name of parent class)

when we need children of parent class => parentClassName.children

also get innerHTML, innerText or textContent

for first child => firstElementChild

for last child => lastElementChild

from child to parent instead of using querySelector that will traverse the whole tree => childName.parent 

switching to sibling element => childName.nextElementSibling

getting know about nodes (means its childrent, line break, bold etc ) => parentClassName.childNodes

creating element => creatElement
setting element attributes (id or class names)  => 

const settingAttributes = document.createElement('h1');
settingAttributes.className = "className";   => same for id

but all these ways override like first they are find that element through out the page then its address and will override that content  (innerHTML etc)

lets use more optimize way

const optimizeWayOfAddingText = document.createTextNode("DOM learning")

settingAttributes.appendChild('optimizeWayOfAddingText ')

document.body.appendChild('settingAttributes')

Existing addition  (adding new li)

1. creation => document.creatElement('li')
2. inner text => innerHTML = inner text
3. where to add => document.querySelector(parent name)
4. append child with parent => parent.appendChild(childName)


Editing

1. selection => querySelector(element:numberth of child(number(2,4,5)))

2. create new element (that you want to edit and add instead of existing element) => createElement (element(li,h2))

3. new content = newElement.textContent = new content

4. oldOne.replaceWith(newOne)

another method 

1. old one select
2. oldOne.outerHTML = html tag with content

remove

1. selection
2.oldOne.remove()





 -->

 <div class="boss">
    <div class="worker">worker 1</div>
    <div class="worker">worker 2</div>
    <div class="worker">worker 3</div>
    <div class="worker">worker 4</div>
 </div>
 
 
 <script>
    const name = document.querySelector('.boss')
    console.log(name);
    console.log(name.children)
    console.log(name.children[1])
    console.log(name.children[1].innerHTML)
    console.log(name.children[1].textContent)
    

    
 </script>
</body>
</html>